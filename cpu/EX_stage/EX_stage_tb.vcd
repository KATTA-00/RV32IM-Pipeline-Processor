$date
	Thu Jan 30 00:55:06 2025
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module EX_stage_tb $end
$var wire 32 ! data2_mux_out [31:0] $end
$var wire 32 " data1_mux_out [31:0] $end
$var wire 1 # branch_logic_out $end
$var wire 32 $ alu_res_out [31:0] $end
$var reg 2 % WB_sel_ex_out [1:0] $end
$var reg 5 & aluop_ex_out [4:0] $end
$var reg 3 ' branch_jump_ex_out [2:0] $end
$var reg 1 ( clk $end
$var reg 32 ) data1_ex_out [31:0] $end
$var reg 1 * data1alusel_ex_out $end
$var reg 32 + data2_ex_out [31:0] $end
$var reg 1 , data2alusel_ex_out $end
$var reg 5 - dest_addr_ex_out [4:0] $end
$var reg 32 . imm_ex_out [31:0] $end
$var reg 32 / pc_ex_out [31:0] $end
$var reg 4 0 read_write_ex_out [3:0] $end
$var reg 1 1 reg_write_en_ex_out $end
$var reg 1 2 rst $end
$scope module alu_inst $end
$var wire 5 3 SELECT [4:0] $end
$var wire 32 4 andData [31:0] $end
$var wire 32 5 forwardData [31:0] $end
$var wire 32 6 mulhData [31:0] $end
$var wire 32 7 mulhsuData [31:0] $end
$var wire 32 8 mulhuData [31:0] $end
$var wire 32 9 orData [31:0] $end
$var wire 32 : xorData [31:0] $end
$var wire 32 ; subData [31:0] $end
$var wire 32 < srlData [31:0] $end
$var wire 32 = sraData [31:0] $end
$var wire 32 > sltuData [31:0] $end
$var wire 32 ? sltData [31:0] $end
$var wire 32 @ sllData [31:0] $end
$var wire 32 A remuData [31:0] $end
$var wire 32 B remData [31:0] $end
$var wire 32 C mulData [31:0] $end
$var wire 32 D divuData [31:0] $end
$var wire 32 E divData [31:0] $end
$var wire 32 F addData [31:0] $end
$var wire 32 G DATA2 [31:0] $end
$var wire 32 H DATA1 [31:0] $end
$var reg 32 I RESULT [31:0] $end
$upscope $end
$scope module branch_logic_inst $end
$var wire 32 J data1 [31:0] $end
$var wire 32 K data2 [31:0] $end
$var wire 3 L op [2:0] $end
$var wire 1 # out $end
$upscope $end
$scope module data1_mux $end
$var wire 32 M a [31:0] $end
$var wire 32 N b [31:0] $end
$var wire 1 * sel $end
$var wire 32 O out [31:0] $end
$upscope $end
$scope module data2_mux $end
$var wire 32 P a [31:0] $end
$var wire 32 Q b [31:0] $end
$var wire 1 , sel $end
$var wire 32 R out [31:0] $end
$upscope $end
$scope module ex_mem_pipeline_reg_inst $end
$var wire 2 S WB_sel_ex_in [1:0] $end
$var wire 32 T alu_result_ex_in [31:0] $end
$var wire 1 ( clk $end
$var wire 5 U dest_addr_ex_in [4:0] $end
$var wire 32 V imm_ex_in [31:0] $end
$var wire 32 W pc_ex_in [31:0] $end
$var wire 32 X read_data2_ex_in [31:0] $end
$var wire 4 Y read_write_ex_in [3:0] $end
$var wire 1 1 reg_write_ex_in $end
$var wire 1 2 rst $end
$var reg 2 Z WB_sel_mem_out [1:0] $end
$var reg 32 [ alu_result_mem_out [31:0] $end
$var reg 5 \ dest_addr_mem_out [4:0] $end
$var reg 32 ] imm_mem_out [31:0] $end
$var reg 32 ^ pc_mem_out [31:0] $end
$var reg 32 _ read_data2_mem_out [31:0] $end
$var reg 4 ` read_write_mem_out [3:0] $end
$var reg 1 a reg_write_mem_out $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
0a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
bx T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
bx I
b0 H
b0 G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
b0 3
12
01
b0 0
b0 /
b0 .
b0 -
0,
b0 +
0*
b0 )
0(
b0 '
b0 &
b0 %
bx $
1#
b0 "
b0 !
$end
#10
b0 $
b0 I
b0 T
b0 4
b0 9
b0 :
b0 =
b0 <
b0 @
b0 5
b0 >
b0 ?
#20
b0 ;
b0 F
#30
b0 C
b0 8
b0 7
b0 6
#50
1(
#100
0(
02
#150
1(
#200
0#
b10 !
b10 G
b10 R
b10 X
b1 "
b1 H
b1 O
0(
b1 &
b1 3
b10 +
b10 K
b10 P
b1 )
b1 J
b1 M
#210
b1 >
b1 ?
b11 9
b11 :
b100 @
b1 5
#220
b11 $
b11 I
b11 T
b11111111111111111111111111111111 ;
b11 F
#230
b1 A
b1 B
b0 D
b0 E
b10 C
#250
b10 _
b11 [
1(
#300
0(
#350
1(
#400
b11111111111111111111111111111111 $
b11111111111111111111111111111111 I
b11111111111111111111111111111111 T
b101 "
b101 H
b101 O
0(
b10 &
b10 3
1,
b10 .
b10 Q
b10 V
b101 )
b101 J
b101 M
#410
b0 >
b0 ?
b111 9
b111 :
b1 =
b1 <
b10100 @
b101 5
#420
b11 $
b11 I
b11 T
b11 ;
b111 F
#430
b10 D
b10 E
b1010 C
#450
b10 ]
1(
#500
0(
#550
1(
#600
1#
b11 "
b11 H
b11 O
0(
b11 +
b11 K
b11 P
b11 )
b11 J
b11 M
#610
b10 4
b11 9
b1 :
b0 =
b0 <
b1100 @
b11 5
#620
b1 $
b1 I
b1 T
b1 ;
b101 F
#630
b1 D
b1 E
b110 C
#650
b1 [
1(
#700
0(
#750
1(
#800
b100 "
b100 H
b100 O
0(
b1 '
b1 L
b101 +
b101 K
b101 P
b100 )
b100 J
b100 M
#810
b0 4
b110 9
b110 :
b1 =
b1 <
b10000 @
b100 5
#820
b10 $
b10 I
b10 T
b10 ;
b110 F
#830
b0 A
b0 B
b10 D
b10 E
b1000 C
#850
b10 [
1(
#900
0(
#950
1(
#1000
0(
