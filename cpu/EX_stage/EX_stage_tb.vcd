$date
	Wed Jan 29 17:23:56 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module EX_stage_tb $end
$var wire 32 ! data2_mux_out [31:0] $end
$var wire 32 " data1_mux_out [31:0] $end
$var wire 1 # branch_logic_out $end
$var wire 32 $ alu_res_out [31:0] $end
$var reg 2 % WB_sel_ex_out [1:0] $end
$var reg 5 & aluop_ex_out [4:0] $end
$var reg 3 ' branch_jump_ex_out [2:0] $end
$var reg 1 ( clk $end
$var reg 32 ) data1_ex_out [31:0] $end
$var reg 1 * data1alusel_ex_out $end
$var reg 32 + data2_ex_out [31:0] $end
$var reg 1 , data2alusel_ex_out $end
$var reg 5 - dest_addr_ex_out [4:0] $end
$var reg 32 . imm_ex_out [31:0] $end
$var reg 32 / pc_ex_out [31:0] $end
$var reg 4 0 read_write_ex_out [3:0] $end
$var reg 1 1 reg_write_en_ex_out $end
$var reg 1 2 rst $end
$scope module alu_inst $end
$var wire 5 3 SELECT [4:0] $end
$var wire 32 4 andData [31:0] $end
$var wire 32 5 forwardData [31:0] $end
$var wire 32 6 mulhData [31:0] $end
$var wire 32 7 mulhsuData [31:0] $end
$var wire 32 8 mulhuData [31:0] $end
$var wire 32 9 orData [31:0] $end
$var wire 32 : xorData [31:0] $end
$var wire 32 ; subData [31:0] $end
$var wire 32 < srlData [31:0] $end
$var wire 32 = sraData [31:0] $end
$var wire 32 > sltuData [31:0] $end
$var wire 32 ? sltData [31:0] $end
$var wire 32 @ sllData [31:0] $end
$var wire 32 A remuData [31:0] $end
$var wire 32 B remData [31:0] $end
$var wire 32 C mulData [31:0] $end
$var wire 32 D divuData [31:0] $end
$var wire 32 E divData [31:0] $end
$var wire 32 F addData [31:0] $end
$var wire 32 G DATA2 [31:0] $end
$var wire 32 H DATA1 [31:0] $end
$var reg 32 I RESULT [31:0] $end
$upscope $end
$scope module branch_logic_inst $end
$var wire 32 J data1 [31:0] $end
$var wire 32 K data2 [31:0] $end
$var wire 3 L op [2:0] $end
$var wire 1 # out $end
$upscope $end
$scope module data1_mux $end
$var wire 32 M a [31:0] $end
$var wire 32 N b [31:0] $end
$var wire 1 * sel $end
$var wire 32 O out [31:0] $end
$upscope $end
$scope module data2_mux $end
$var wire 32 P a [31:0] $end
$var wire 32 Q b [31:0] $end
$var wire 1 , sel $end
$var wire 32 R out [31:0] $end
$upscope $end
$scope module ex_mem_pipeline_reg_inst $end
$var wire 2 S WB_sel_ex_in [1:0] $end
$var wire 32 T alu_result_ex_in [31:0] $end
$var wire 1 ( clk $end
$var wire 5 U dest_addr_ex_in [4:0] $end
$var wire 32 V imm_ex_in [31:0] $end
$var wire 32 W pc_ex_in [31:0] $end
$var wire 32 X read_data2_ex_in [31:0] $end
$var wire 4 Y read_write_ex_in [3:0] $end
$var wire 1 1 reg_write_ex_in $end
$var wire 1 2 rst $end
$var reg 2 Z WB_sel_mem_out [1:0] $end
$var reg 32 [ alu_result_mem_out [31:0] $end
$var reg 5 \ dest_addr_mem_out [4:0] $end
$var reg 32 ] imm_mem_out [31:0] $end
$var reg 32 ^ pc_mem_out [31:0] $end
$var reg 32 _ read_data2_mem_out [31:0] $end
$var reg 4 ` read_write_mem_out [3:0] $end
$var reg 1 a reg_write_mem_out $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
0a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
bx T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
bx I
b0 H
b0 G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
b0 3
12
01
b0 0
b0 /
b0 .
b0 -
0,
b0 +
0*
b0 )
0(
b0 '
b0 &
b0 %
bx $
1#
b0 "
b0 !
$end
#1
b0 $
b0 I
b0 T
b0 4
b0 9
b0 :
b0 =
b0 <
b0 @
b0 5
b0 >
b0 ?
#2
b0 ;
b0 F
#3
b0 C
b0 8
b0 7
b0 6
#5
1(
#10
0(
02
#15
1(
#20
0#
b10 !
b10 G
b10 R
b10 X
0(
b1 &
b1 3
b10 +
b10 K
b10 P
b1 )
b1 J
b1 N
#21
b1 >
b1 ?
b10 9
b10 :
#22
b10 $
b10 I
b10 T
b11111111111111111111111111111110 ;
b10 F
#23
b0 A
b0 B
b0 D
b0 E
#25
b10 _
b10 [
1(
#30
0(
#35
1(
#40
b11111111111111111111111111111110 $
b11111111111111111111111111111110 I
b11111111111111111111111111111110 T
0(
b10 &
b10 3
1,
b10 .
b10 Q
b10 V
b101 )
b101 J
b101 N
#45
b10 ]
b11111111111111111111111111111110 [
1(
#50
0(
#55
1(
#60
1#
0(
b11 +
b11 K
b11 P
b11 )
b11 J
b11 N
#65
1(
#70
0(
#75
1(
#80
0(
b1 '
b1 L
b101 +
b101 K
b101 P
b100 )
b100 J
b100 N
#85
1(
#90
0(
#95
1(
#100
0(
